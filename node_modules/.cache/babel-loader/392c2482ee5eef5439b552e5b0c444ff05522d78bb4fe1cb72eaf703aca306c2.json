{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LoadBalancingCall = void 0;\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst constants_1 = require(\"./constants\");\nconst deadline_1 = require(\"./deadline\");\nconst metadata_1 = require(\"./metadata\");\nconst picker_1 = require(\"./picker\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst logging = require(\"./logging\");\nconst control_plane_status_1 = require(\"./control-plane-status\");\nconst http2 = require(\"http2\");\nconst TRACER_NAME = 'load_balancing_call';\nclass LoadBalancingCall {\n  constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {\n    var _a, _b;\n    this.channel = channel;\n    this.callConfig = callConfig;\n    this.methodName = methodName;\n    this.host = host;\n    this.credentials = credentials;\n    this.deadline = deadline;\n    this.callNumber = callNumber;\n    this.child = null;\n    this.readPending = false;\n    this.pendingMessage = null;\n    this.pendingHalfClose = false;\n    this.ended = false;\n    this.metadata = null;\n    this.listener = null;\n    this.onCallEnded = null;\n    const splitPath = this.methodName.split('/');\n    let serviceName = '';\n    /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n     * by '/', the first item should be empty and the second should be the\n     * service name */\n    if (splitPath.length >= 2) {\n      serviceName = splitPath[1];\n    }\n    const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\n    /* Currently, call credentials are only allowed on HTTPS connections, so we\n     * can assume that the scheme is \"https\" */\n    this.serviceUrl = `https://${hostname}/${serviceName}`;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n  }\n  outputStatus(status, progress) {\n    var _a, _b;\n    if (!this.ended) {\n      this.ended = true;\n      this.trace('ended with status: code=' + status.code + ' details=\"' + status.details + '\"');\n      const finalStatus = Object.assign(Object.assign({}, status), {\n        progress\n      });\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);\n      (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code);\n    }\n  }\n  doPick() {\n    var _a, _b;\n    if (this.ended) {\n      return;\n    }\n    if (!this.metadata) {\n      throw new Error('doPick called before start');\n    }\n    this.trace('Pick called');\n    const pickResult = this.channel.doPick(this.metadata, this.callConfig.pickInformation);\n    const subchannelString = pickResult.subchannel ? '(' + pickResult.subchannel.getChannelzRef().id + ') ' + pickResult.subchannel.getAddress() : '' + pickResult.subchannel;\n    this.trace('Pick result: ' + picker_1.PickResultType[pickResult.pickResultType] + ' subchannel: ' + subchannelString + ' status: ' + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) + ' ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n    switch (pickResult.pickResultType) {\n      case picker_1.PickResultType.COMPLETE:\n        this.credentials.generateMetadata({\n          service_url: this.serviceUrl\n        }).then(credsMetadata => {\n          var _a, _b, _c;\n          const finalMetadata = this.metadata.clone();\n          finalMetadata.merge(credsMetadata);\n          if (finalMetadata.get('authorization').length > 1) {\n            this.outputStatus({\n              code: constants_1.Status.INTERNAL,\n              details: '\"authorization\" metadata cannot have multiple values',\n              metadata: new metadata_1.Metadata()\n            }, 'PROCESSED');\n          }\n          if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n            this.trace('Picked subchannel ' + subchannelString + ' has state ' + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] + ' after getting credentials metadata. Retrying pick');\n            this.doPick();\n            return;\n          }\n          if (this.deadline !== Infinity) {\n            finalMetadata.set('grpc-timeout', (0, deadline_1.getDeadlineTimeoutString)(this.deadline));\n          }\n          try {\n            this.child = pickResult.subchannel.getRealSubchannel().createCall(finalMetadata, this.host, this.methodName, {\n              onReceiveMetadata: metadata => {\n                this.trace('Received metadata');\n                this.listener.onReceiveMetadata(metadata);\n              },\n              onReceiveMessage: message => {\n                this.trace('Received message');\n                this.listener.onReceiveMessage(message);\n              },\n              onReceiveStatus: status => {\n                this.trace('Received status');\n                if (status.rstCode === http2.constants.NGHTTP2_REFUSED_STREAM) {\n                  this.outputStatus(status, 'REFUSED');\n                } else {\n                  this.outputStatus(status, 'PROCESSED');\n                }\n              }\n            });\n          } catch (error) {\n            this.trace('Failed to start call on picked subchannel ' + subchannelString + ' with error ' + error.message);\n            this.outputStatus({\n              code: constants_1.Status.INTERNAL,\n              details: 'Failed to start HTTP/2 stream with error ' + error.message,\n              metadata: new metadata_1.Metadata()\n            }, 'NOT_STARTED');\n            return;\n          }\n          (_b = (_a = this.callConfig).onCommitted) === null || _b === void 0 ? void 0 : _b.call(_a);\n          (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n          this.onCallEnded = pickResult.onCallEnded;\n          this.trace('Created child call [' + this.child.getCallNumber() + ']');\n          if (this.readPending) {\n            this.child.startRead();\n          }\n          if (this.pendingMessage) {\n            this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);\n          }\n          if (this.pendingHalfClose) {\n            this.child.halfClose();\n          }\n        }, error => {\n          // We assume the error code isn't 0 (Status.OK)\n          const {\n            code,\n            details\n          } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n          this.outputStatus({\n            code: code,\n            details: details,\n            metadata: new metadata_1.Metadata()\n          }, 'PROCESSED');\n        });\n        break;\n      case picker_1.PickResultType.DROP:\n        const {\n          code,\n          details\n        } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n        setImmediate(() => {\n          this.outputStatus({\n            code,\n            details,\n            metadata: pickResult.status.metadata\n          }, 'DROP');\n        });\n        break;\n      case picker_1.PickResultType.TRANSIENT_FAILURE:\n        if (this.metadata.getOptions().waitForReady) {\n          this.channel.queueCallForPick(this);\n        } else {\n          const {\n            code,\n            details\n          } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n          setImmediate(() => {\n            this.outputStatus({\n              code,\n              details,\n              metadata: pickResult.status.metadata\n            }, 'PROCESSED');\n          });\n        }\n        break;\n      case picker_1.PickResultType.QUEUE:\n        this.channel.queueCallForPick(this);\n    }\n  }\n  cancelWithStatus(status, details) {\n    var _a;\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n    this.outputStatus({\n      code: status,\n      details: details,\n      metadata: new metadata_1.Metadata()\n    }, 'PROCESSED');\n  }\n  getPeer() {\n    var _a, _b;\n    return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n  }\n  start(metadata, listener) {\n    this.trace('start called');\n    this.listener = listener;\n    this.metadata = metadata;\n    this.doPick();\n  }\n  sendMessageWithContext(context, message) {\n    this.trace('write() called with message of length ' + message.length);\n    if (this.child) {\n      this.child.sendMessageWithContext(context, message);\n    } else {\n      this.pendingMessage = {\n        context,\n        message\n      };\n    }\n  }\n  startRead() {\n    this.trace('startRead called');\n    if (this.child) {\n      this.child.startRead();\n    } else {\n      this.readPending = true;\n    }\n  }\n  halfClose() {\n    this.trace('halfClose called');\n    if (this.child) {\n      this.child.halfClose();\n    } else {\n      this.pendingHalfClose = true;\n    }\n  }\n  setCredentials(credentials) {\n    throw new Error('Method not implemented.');\n  }\n  getCallNumber() {\n    return this.callNumber;\n  }\n}\nexports.LoadBalancingCall = LoadBalancingCall;","map":{"version":3,"names":["connectivity_state_1","require","constants_1","deadline_1","metadata_1","picker_1","uri_parser_1","logging","control_plane_status_1","http2","TRACER_NAME","LoadBalancingCall","constructor","channel","callConfig","methodName","host","credentials","deadline","callNumber","child","readPending","pendingMessage","pendingHalfClose","ended","metadata","listener","onCallEnded","splitPath","split","serviceName","length","hostname","_b","_a","splitHostPort","serviceUrl","trace","text","LogVerbosity","DEBUG","outputStatus","status","progress","code","details","finalStatus","Object","assign","onReceiveStatus","call","doPick","Error","pickResult","pickInformation","subchannelString","subchannel","getChannelzRef","id","getAddress","PickResultType","pickResultType","COMPLETE","generateMetadata","service_url","then","credsMetadata","finalMetadata","clone","merge","get","Status","INTERNAL","Metadata","getConnectivityState","ConnectivityState","READY","Infinity","set","getDeadlineTimeoutString","getRealSubchannel","createCall","onReceiveMetadata","onReceiveMessage","message","rstCode","constants","NGHTTP2_REFUSED_STREAM","error","onCommitted","_c","onCallStarted","getCallNumber","startRead","sendMessageWithContext","context","halfClose","restrictControlPlaneStatusCode","UNKNOWN","DROP","setImmediate","TRANSIENT_FAILURE","getOptions","waitForReady","queueCallForPick","QUEUE","cancelWithStatus","getPeer","getTarget","start","setCredentials","exports"],"sources":["/Users/juanrodriguez/Documents/projects/face-detection-app/node_modules/@grpc/grpc-js/src/load-balancing-call.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { CallCredentials } from './call-credentials';\nimport {\n  Call,\n  InterceptingListener,\n  MessageContext,\n  StatusObject,\n} from './call-interface';\nimport { SubchannelCall } from './subchannel-call';\nimport { ConnectivityState } from './connectivity-state';\nimport { LogVerbosity, Status } from './constants';\nimport { Deadline, getDeadlineTimeoutString } from './deadline';\nimport { InternalChannel } from './internal-channel';\nimport { Metadata } from './metadata';\nimport { PickResultType } from './picker';\nimport { CallConfig } from './resolver';\nimport { splitHostPort } from './uri-parser';\nimport * as logging from './logging';\nimport { restrictControlPlaneStatusCode } from './control-plane-status';\nimport * as http2 from 'http2';\n\nconst TRACER_NAME = 'load_balancing_call';\n\nexport type RpcProgress = 'NOT_STARTED' | 'DROP' | 'REFUSED' | 'PROCESSED';\n\nexport interface StatusObjectWithProgress extends StatusObject {\n  progress: RpcProgress;\n}\n\nexport interface LoadBalancingCallInterceptingListener\n  extends InterceptingListener {\n  onReceiveStatus(status: StatusObjectWithProgress): void;\n}\n\nexport class LoadBalancingCall implements Call {\n  private child: SubchannelCall | null = null;\n  private readPending = false;\n  private pendingMessage: { context: MessageContext; message: Buffer } | null =\n    null;\n  private pendingHalfClose = false;\n  private ended = false;\n  private serviceUrl: string;\n  private metadata: Metadata | null = null;\n  private listener: InterceptingListener | null = null;\n  private onCallEnded: ((statusCode: Status) => void) | null = null;\n  constructor(\n    private readonly channel: InternalChannel,\n    private readonly callConfig: CallConfig,\n    private readonly methodName: string,\n    private readonly host: string,\n    private readonly credentials: CallCredentials,\n    private readonly deadline: Deadline,\n    private readonly callNumber: number\n  ) {\n    const splitPath: string[] = this.methodName.split('/');\n    let serviceName = '';\n    /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n     * by '/', the first item should be empty and the second should be the\n     * service name */\n    if (splitPath.length >= 2) {\n      serviceName = splitPath[1];\n    }\n    const hostname = splitHostPort(this.host)?.host ?? 'localhost';\n    /* Currently, call credentials are only allowed on HTTPS connections, so we\n     * can assume that the scheme is \"https\" */\n    this.serviceUrl = `https://${hostname}/${serviceName}`;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callNumber + '] ' + text\n    );\n  }\n\n  private outputStatus(status: StatusObject, progress: RpcProgress) {\n    if (!this.ended) {\n      this.ended = true;\n      this.trace(\n        'ended with status: code=' +\n          status.code +\n          ' details=\"' +\n          status.details +\n          '\"'\n      );\n      const finalStatus = { ...status, progress };\n      this.listener?.onReceiveStatus(finalStatus);\n      this.onCallEnded?.(finalStatus.code);\n    }\n  }\n\n  doPick() {\n    if (this.ended) {\n      return;\n    }\n    if (!this.metadata) {\n      throw new Error('doPick called before start');\n    }\n    this.trace('Pick called');\n    const pickResult = this.channel.doPick(\n      this.metadata,\n      this.callConfig.pickInformation\n    );\n    const subchannelString = pickResult.subchannel\n      ? '(' +\n        pickResult.subchannel.getChannelzRef().id +\n        ') ' +\n        pickResult.subchannel.getAddress()\n      : '' + pickResult.subchannel;\n    this.trace(\n      'Pick result: ' +\n        PickResultType[pickResult.pickResultType] +\n        ' subchannel: ' +\n        subchannelString +\n        ' status: ' +\n        pickResult.status?.code +\n        ' ' +\n        pickResult.status?.details\n    );\n    switch (pickResult.pickResultType) {\n      case PickResultType.COMPLETE:\n        this.credentials\n          .generateMetadata({ service_url: this.serviceUrl })\n          .then(\n            credsMetadata => {\n              const finalMetadata = this.metadata!.clone();\n              finalMetadata.merge(credsMetadata);\n              if (finalMetadata.get('authorization').length > 1) {\n                this.outputStatus(\n                  {\n                    code: Status.INTERNAL,\n                    details:\n                      '\"authorization\" metadata cannot have multiple values',\n                    metadata: new Metadata(),\n                  },\n                  'PROCESSED'\n                );\n              }\n              if (\n                pickResult.subchannel!.getConnectivityState() !==\n                ConnectivityState.READY\n              ) {\n                this.trace(\n                  'Picked subchannel ' +\n                    subchannelString +\n                    ' has state ' +\n                    ConnectivityState[\n                      pickResult.subchannel!.getConnectivityState()\n                    ] +\n                    ' after getting credentials metadata. Retrying pick'\n                );\n                this.doPick();\n                return;\n              }\n\n              if (this.deadline !== Infinity) {\n                finalMetadata.set(\n                  'grpc-timeout',\n                  getDeadlineTimeoutString(this.deadline)\n                );\n              }\n              try {\n                this.child = pickResult\n                  .subchannel!.getRealSubchannel()\n                  .createCall(finalMetadata, this.host, this.methodName, {\n                    onReceiveMetadata: metadata => {\n                      this.trace('Received metadata');\n                      this.listener!.onReceiveMetadata(metadata);\n                    },\n                    onReceiveMessage: message => {\n                      this.trace('Received message');\n                      this.listener!.onReceiveMessage(message);\n                    },\n                    onReceiveStatus: status => {\n                      this.trace('Received status');\n                      if (\n                        status.rstCode ===\n                        http2.constants.NGHTTP2_REFUSED_STREAM\n                      ) {\n                        this.outputStatus(status, 'REFUSED');\n                      } else {\n                        this.outputStatus(status, 'PROCESSED');\n                      }\n                    },\n                  });\n              } catch (error) {\n                this.trace(\n                  'Failed to start call on picked subchannel ' +\n                    subchannelString +\n                    ' with error ' +\n                    (error as Error).message\n                );\n                this.outputStatus(\n                  {\n                    code: Status.INTERNAL,\n                    details:\n                      'Failed to start HTTP/2 stream with error ' +\n                      (error as Error).message,\n                    metadata: new Metadata(),\n                  },\n                  'NOT_STARTED'\n                );\n                return;\n              }\n              this.callConfig.onCommitted?.();\n              pickResult.onCallStarted?.();\n              this.onCallEnded = pickResult.onCallEnded;\n              this.trace(\n                'Created child call [' + this.child.getCallNumber() + ']'\n              );\n              if (this.readPending) {\n                this.child.startRead();\n              }\n              if (this.pendingMessage) {\n                this.child.sendMessageWithContext(\n                  this.pendingMessage.context,\n                  this.pendingMessage.message\n                );\n              }\n              if (this.pendingHalfClose) {\n                this.child.halfClose();\n              }\n            },\n            (error: Error & { code: number }) => {\n              // We assume the error code isn't 0 (Status.OK)\n              const { code, details } = restrictControlPlaneStatusCode(\n                typeof error.code === 'number' ? error.code : Status.UNKNOWN,\n                `Getting metadata from plugin failed with error: ${error.message}`\n              );\n              this.outputStatus(\n                {\n                  code: code,\n                  details: details,\n                  metadata: new Metadata(),\n                },\n                'PROCESSED'\n              );\n            }\n          );\n        break;\n      case PickResultType.DROP:\n        const { code, details } = restrictControlPlaneStatusCode(\n          pickResult.status!.code,\n          pickResult.status!.details\n        );\n        setImmediate(() => {\n          this.outputStatus(\n            { code, details, metadata: pickResult.status!.metadata },\n            'DROP'\n          );\n        });\n        break;\n      case PickResultType.TRANSIENT_FAILURE:\n        if (this.metadata.getOptions().waitForReady) {\n          this.channel.queueCallForPick(this);\n        } else {\n          const { code, details } = restrictControlPlaneStatusCode(\n            pickResult.status!.code,\n            pickResult.status!.details\n          );\n          setImmediate(() => {\n            this.outputStatus(\n              { code, details, metadata: pickResult.status!.metadata },\n              'PROCESSED'\n            );\n          });\n        }\n        break;\n      case PickResultType.QUEUE:\n        this.channel.queueCallForPick(this);\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace(\n      'cancelWithStatus code: ' + status + ' details: \"' + details + '\"'\n    );\n    this.child?.cancelWithStatus(status, details);\n    this.outputStatus(\n      { code: status, details: details, metadata: new Metadata() },\n      'PROCESSED'\n    );\n  }\n  getPeer(): string {\n    return this.child?.getPeer() ?? this.channel.getTarget();\n  }\n  start(\n    metadata: Metadata,\n    listener: LoadBalancingCallInterceptingListener\n  ): void {\n    this.trace('start called');\n    this.listener = listener;\n    this.metadata = metadata;\n    this.doPick();\n  }\n  sendMessageWithContext(context: MessageContext, message: Buffer): void {\n    this.trace('write() called with message of length ' + message.length);\n    if (this.child) {\n      this.child.sendMessageWithContext(context, message);\n    } else {\n      this.pendingMessage = { context, message };\n    }\n  }\n  startRead(): void {\n    this.trace('startRead called');\n    if (this.child) {\n      this.child.startRead();\n    } else {\n      this.readPending = true;\n    }\n  }\n  halfClose(): void {\n    this.trace('halfClose called');\n    if (this.child) {\n      this.child.halfClose();\n    } else {\n      this.pendingHalfClose = true;\n    }\n  }\n  setCredentials(credentials: CallCredentials): void {\n    throw new Error('Method not implemented.');\n  }\n\n  getCallNumber(): number {\n    return this.callNumber;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}