{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2SubchannelConnector = void 0;\nconst http2 = require(\"http2\");\nconst tls_1 = require(\"tls\");\nconst channelz_1 = require(\"./channelz\");\nconst constants_1 = require(\"./constants\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst logging = require(\"./logging\");\nconst resolver_1 = require(\"./resolver\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst net = require(\"net\");\nconst subchannel_call_1 = require(\"./subchannel-call\");\nconst call_number_1 = require(\"./call-number\");\nconst TRACER_NAME = 'transport';\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\nconst clientVersion = require('../../package.json').version;\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT\n} = http2.constants;\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nclass Http2Transport {\n  constructor(session, subchannelAddress, options,\n  /**\n   * Name of the remote server, if it is not the same as the subchannel\n   * address, i.e. if connecting through an HTTP CONNECT proxy.\n   */\n  remoteName) {\n    this.session = session;\n    this.remoteName = remoteName;\n    /**\n     * The amount of time in between sending pings\n     */\n    this.keepaliveTimeMs = -1;\n    /**\n     * The amount of time to wait for an acknowledgement after sending a ping\n     */\n    this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    /**\n     * Timer reference for timeout that indicates when to send the next ping\n     */\n    this.keepaliveTimerId = null;\n    /**\n     * Indicates that the keepalive timer ran out while there were no active\n     * calls, and a ping should be sent the next time a call starts.\n     */\n    this.pendingSendKeepalivePing = false;\n    /**\n     * Timer reference tracking when the most recent ping will be considered lost\n     */\n    this.keepaliveTimeoutId = null;\n    /**\n     * Indicates whether keepalive pings should be sent without any active calls\n     */\n    this.keepaliveWithoutCalls = false;\n    this.activeCalls = new Set();\n    this.disconnectListeners = [];\n    this.disconnectHandled = false;\n    this.channelzEnabled = true;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n    /* Populate subchannelAddressString and channelzRef before doing anything\n     * else, because they are used in the trace methods. */\n    this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    // Build user-agent string.\n    this.userAgent = [options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`, options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls = options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    session.once('close', () => {\n      this.trace('session closed');\n      this.stopKeepalivePings();\n      this.handleDisconnect();\n    });\n    session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n      let tooManyPings = false;\n      /* See the last paragraph of\n       * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n      if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {\n        tooManyPings = true;\n      }\n      this.trace('connection closed by GOAWAY with code ' + errorCode);\n      this.reportDisconnectToOwner(tooManyPings);\n    });\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace('connection closed with error ' + error.message);\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', settings => {\n        this.trace('new settings received' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n      session.on('localSettings', settings => {\n        this.trace('local settings acknowledged by remote' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n    }\n    /* Start the keepalive timer last, because this can trigger trace logs,\n     * which should only happen after everything else is set up. */\n    if (this.keepaliveWithoutCalls) {\n      this.maybeStartKeepalivePingTimer();\n    }\n  }\n  getChannelzInfo() {\n    var _a, _b, _c;\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo;\n    if (this.session.encrypted) {\n      const tlsSocket = sessionSocket;\n      const cipherInfo = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n      remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n    };\n    return socketInfo;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  keepaliveTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  flowControlTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  internalsTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'transport_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  /**\n   * Indicate to the owner of this object that this transport should no longer\n   * be used. That happens if the connection drops, or if the server sends a\n   * GOAWAY.\n   * @param tooManyPings If true, this was triggered by a GOAWAY with data\n   * indicating that the session was closed becaues the client sent too many\n   * pings.\n   * @returns\n   */\n  reportDisconnectToOwner(tooManyPings) {\n    if (this.disconnectHandled) {\n      return;\n    }\n    this.disconnectHandled = true;\n    this.disconnectListeners.forEach(listener => listener(tooManyPings));\n  }\n  /**\n   * Handle connection drops, but not GOAWAYs.\n   */\n  handleDisconnect() {\n    this.reportDisconnectToOwner(false);\n    /* Give calls an event loop cycle to finish naturally before reporting the\n     * disconnnection to them. */\n    setImmediate(() => {\n      for (const call of this.activeCalls) {\n        call.onDisconnect();\n      }\n    });\n  }\n  addDisconnectListener(listener) {\n    this.disconnectListeners.push(listener);\n  }\n  clearKeepaliveTimer() {\n    if (!this.keepaliveTimerId) {\n      return;\n    }\n    clearTimeout(this.keepaliveTimerId);\n    this.keepaliveTimerId = null;\n  }\n  clearKeepaliveTimeout() {\n    if (!this.keepaliveTimeoutId) {\n      return;\n    }\n    clearTimeout(this.keepaliveTimeoutId);\n    this.keepaliveTimeoutId = null;\n  }\n  canSendPing() {\n    return this.keepaliveTimeMs > 0 && (this.keepaliveWithoutCalls || this.activeCalls.size > 0);\n  }\n  maybeSendPing() {\n    var _a, _b;\n    this.clearKeepaliveTimer();\n    if (!this.canSendPing()) {\n      this.pendingSendKeepalivePing = true;\n      return;\n    }\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    if (!this.keepaliveTimeoutId) {\n      this.keepaliveTimeoutId = setTimeout(() => {\n        this.keepaliveTrace('Ping timeout passed without response');\n        this.handleDisconnect();\n      }, this.keepaliveTimeoutMs);\n      (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    try {\n      this.session.ping((err, duration, payload) => {\n        this.keepaliveTrace('Received ping response');\n        this.clearKeepaliveTimeout();\n        this.maybeStartKeepalivePingTimer();\n      });\n    } catch (e) {\n      /* If we fail to send a ping, the connection is no longer functional, so\n       * we should discard it. */\n      this.handleDisconnect();\n    }\n  }\n  /**\n   * Starts the keepalive ping timer if appropriate. If the timer already ran\n   * out while there were no active requests, instead send a ping immediately.\n   * If the ping timer is already running or a ping is currently in flight,\n   * instead do nothing and wait for them to resolve.\n   */\n  maybeStartKeepalivePingTimer() {\n    var _a, _b;\n    if (!this.canSendPing()) {\n      return;\n    }\n    if (this.pendingSendKeepalivePing) {\n      this.pendingSendKeepalivePing = false;\n      this.maybeSendPing();\n    } else if (!this.keepaliveTimerId && !this.keepaliveTimeoutId) {\n      this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\n      this.keepaliveTimerId = (_b = (_a = setTimeout(() => {\n        this.maybeSendPing();\n      }, this.keepaliveTimeMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /* Otherwise, there is already either a keepalive timer or a ping pending,\n     * wait for those to resolve. */\n  }\n\n  stopKeepalivePings() {\n    if (this.keepaliveTimerId) {\n      clearTimeout(this.keepaliveTimerId);\n      this.keepaliveTimerId = null;\n    }\n    this.clearKeepaliveTimeout();\n  }\n  removeActiveCall(call) {\n    this.activeCalls.delete(call);\n    if (this.activeCalls.size === 0) {\n      this.session.unref();\n    }\n  }\n  addActiveCall(call) {\n    this.activeCalls.add(call);\n    if (this.activeCalls.size === 1) {\n      this.session.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.maybeStartKeepalivePingTimer();\n      }\n    }\n  }\n  createCall(metadata, host, method, listener, subchannelCallStatsTracker) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = host;\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = method;\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session.request(headers);\n    } catch (e) {\n      this.handleDisconnect();\n      throw e;\n    }\n    this.flowControlTrace('local window size: ' + this.session.state.localWindowSize + ' remote window size: ' + this.session.state.remoteWindowSize);\n    this.internalsTrace('session.closed=' + this.session.closed + ' session.destroyed=' + this.session.destroyed + ' session.socket.destroyed=' + this.session.socket.destroyed);\n    let eventTracker;\n    // eslint-disable-next-line prefer-const\n    let call;\n    if (this.channelzEnabled) {\n      this.streamTracker.addCallStarted();\n      eventTracker = {\n        addMessageSent: () => {\n          var _a;\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n          (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        addMessageReceived: () => {\n          var _a;\n          this.messagesReceived += 1;\n          this.lastMessageReceivedTimestamp = new Date();\n          (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        onCallEnd: status => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          var _a;\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n          (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n        }\n      };\n    } else {\n      eventTracker = {\n        addMessageSent: () => {\n          var _a;\n          (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        addMessageReceived: () => {\n          var _a;\n          (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        onCallEnd: status => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n        }\n      };\n    }\n    call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());\n    this.addActiveCall(call);\n    return call;\n  }\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  getPeerName() {\n    return this.subchannelAddressString;\n  }\n  shutdown() {\n    this.session.close();\n    (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n  }\n}\nclass Http2SubchannelConnector {\n  constructor(channelTarget) {\n    this.channelTarget = channelTarget;\n    this.session = null;\n    this.isShutdown = false;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + ' ' + text);\n  }\n  createSession(address, credentials, options, proxyConnectionResult) {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    return new Promise((resolve, reject) => {\n      var _a, _b, _c;\n      let remoteName;\n      if (proxyConnectionResult.realTarget) {\n        remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);\n        this.trace('creating HTTP/2 session through proxy to ' + (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));\n      } else {\n        remoteName = null;\n        this.trace('creating HTTP/2 session to ' + (0, subchannel_address_1.subchannelAddressToString)(address));\n      }\n      const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n      let connectionOptions = credentials._getConnectionOptions() || {};\n      connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n      if ('grpc-node.max_session_memory' in options) {\n        connectionOptions.maxSessionMemory = options['grpc-node.max_session_memory'];\n      } else {\n        /* By default, set a very large max session memory limit, to effectively\n         * disable enforcement of the limit. Some testing indicates that Node's\n         * behavior degrades badly when this limit is reached, so we solve that\n         * by disabling the check entirely. */\n        connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n      }\n      let addressScheme = 'http://';\n      if ('secureContext' in connectionOptions) {\n        addressScheme = 'https://';\n        // If provided, the value of grpc.ssl_target_name_override should be used\n        // to override the target hostname when checking server identity.\n        // This option is used for testing only.\n        if (options['grpc.ssl_target_name_override']) {\n          const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\n          connectionOptions.checkServerIdentity = (host, cert) => {\n            return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n          };\n          connectionOptions.servername = sslTargetNameOverride;\n        } else {\n          const authorityHostname = (_c = (_b = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost';\n          // We want to always set servername to support SNI\n          connectionOptions.servername = authorityHostname;\n        }\n        if (proxyConnectionResult.socket) {\n          /* This is part of the workaround for\n           * https://github.com/nodejs/node/issues/32922. Without that bug,\n           * proxyConnectionResult.socket would always be a plaintext socket and\n           * this would say\n           * connectionOptions.socket = proxyConnectionResult.socket; */\n          connectionOptions.createConnection = (authority, option) => {\n            return proxyConnectionResult.socket;\n          };\n        }\n      } else {\n        /* In all but the most recent versions of Node, http2.connect does not use\n         * the options when establishing plaintext connections, so we need to\n         * establish that connection explicitly. */\n        connectionOptions.createConnection = (authority, option) => {\n          if (proxyConnectionResult.socket) {\n            return proxyConnectionResult.socket;\n          } else {\n            /* net.NetConnectOpts is declared in a way that is more restrictive\n             * than what net.connect will actually accept, so we use the type\n             * assertion to work around that. */\n            return net.connect(address);\n          }\n        };\n      }\n      connectionOptions = Object.assign(Object.assign(Object.assign({}, connectionOptions), address), {\n        enableTrace: options['grpc-node.tls_enable_trace'] === 1\n      });\n      /* http2.connect uses the options here:\n       * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n       * The spread operator overides earlier values with later ones, so any port\n       * or host values in the options will be used rather than any values extracted\n       * from the first argument. In addition, the path overrides the host and port,\n       * as documented for plaintext connections here:\n       * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n       * and for TLS connections here:\n       * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n       * earlier versions of Node, http2.connect passes these options to\n       * tls.connect but not net.connect, so in the insecure case we still need\n       * to set the createConnection option above to create the connection\n       * explicitly. We cannot do that in the TLS case because http2.connect\n       * passes necessary additional options to tls.connect.\n       * The first argument just needs to be parseable as a URL and the scheme\n       * determines whether the connection will be established over TLS or not.\n       */\n      const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n      this.session = session;\n      session.unref();\n      session.once('connect', () => {\n        session.removeAllListeners();\n        resolve(new Http2Transport(session, address, options, remoteName));\n        this.session = null;\n      });\n      session.once('close', () => {\n        this.session = null;\n        reject();\n      });\n      session.once('error', error => {\n        this.trace('connection failed with error ' + error.message);\n      });\n    });\n  }\n  connect(address, credentials, options) {\n    var _a, _b;\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions = credentials._getConnectionOptions() || {};\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = (0, resolver_1.getDefaultAuthority)((_a = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\n            path: 'localhost'\n          });\n          const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n          connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n        }\n      }\n      if (options['grpc-node.tls_enable_trace']) {\n        connectionOptions.enableTrace = true;\n      }\n    }\n    return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then(result => this.createSession(address, credentials, options, result));\n  }\n  shutdown() {\n    var _a;\n    this.isShutdown = true;\n    (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();\n    this.session = null;\n  }\n}\nexports.Http2SubchannelConnector = Http2SubchannelConnector;","map":{"version":3,"names":["http2","require","tls_1","channelz_1","constants_1","http_proxy_1","logging","resolver_1","subchannel_address_1","uri_parser_1","net","subchannel_call_1","call_number_1","TRACER_NAME","FLOW_CONTROL_TRACER_NAME","clientVersion","version","HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_CONTENT_TYPE","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_TE","HTTP2_HEADER_USER_AGENT","constants","KEEPALIVE_TIMEOUT_MS","tooManyPingsData","Buffer","from","Http2Transport","constructor","session","subchannelAddress","options","remoteName","keepaliveTimeMs","keepaliveTimeoutMs","keepaliveTimerId","pendingSendKeepalivePing","keepaliveTimeoutId","keepaliveWithoutCalls","activeCalls","Set","disconnectListeners","disconnectHandled","channelzEnabled","streamTracker","ChannelzCallTracker","keepalivesSent","messagesSent","messagesReceived","lastMessageSentTimestamp","lastMessageReceivedTimestamp","subchannelAddressString","subchannelAddressToString","channelzRef","registerChannelzSocket","getChannelzInfo","userAgent","filter","e","join","once","trace","stopKeepalivePings","handleDisconnect","errorCode","lastStreamID","opaqueData","tooManyPings","NGHTTP2_ENHANCE_YOUR_CALM","equals","reportDisconnectToOwner","error","message","isTracerEnabled","on","settings","JSON","stringify","maybeStartKeepalivePingTimer","sessionSocket","socket","remoteAddress","stringToSubchannelAddress","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","_a","standardName","cipherSuiteOtherName","name","localCertificate","raw","remoteCertificate","socketInfo","security","streamsStarted","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","keepAlivesSent","lastLocalStreamCreatedTimestamp","lastCallStartedTimestamp","lastRemoteStreamCreatedTimestamp","localFlowControlWindow","_b","state","localWindowSize","remoteFlowControlWindow","_c","remoteWindowSize","text","LogVerbosity","DEBUG","id","keepaliveTrace","flowControlTrace","internalsTrace","forEach","listener","setImmediate","call","onDisconnect","addDisconnectListener","push","clearKeepaliveTimer","clearTimeout","clearKeepaliveTimeout","canSendPing","size","maybeSendPing","setTimeout","unref","ping","err","duration","payload","removeActiveCall","delete","addActiveCall","add","ref","createCall","metadata","host","method","subchannelCallStatsTracker","headers","toHttp2Headers","http2Stream","request","closed","destroyed","eventTracker","addCallStarted","addMessageSent","Date","addMessageReceived","onCallEnd","status","onStreamEnd","success","addCallSucceeded","addCallFailed","Http2SubchannelCall","getNextCallNumber","getChannelzRef","getPeerName","shutdown","close","unregisterChannelzRef","Http2SubchannelConnector","channelTarget","isShutdown","uriToString","createSession","address","credentials","proxyConnectionResult","Promise","reject","resolve","realTarget","targetAuthority","getDefaultAuthority","connectionOptions","_getConnectionOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","addressScheme","sslTargetNameOverride","checkServerIdentity","cert","servername","authorityHostname","splitHostPort","createConnection","authority","option","connect","Object","assign","enableTrace","removeAllListeners","ALPNProtocols","targetPath","parseUri","path","hostPort","getProxiedConnection","then","result","exports"],"sources":["/Users/juanrodriguez/Documents/projects/face-detection-app/node_modules/@grpc/grpc-js/src/transport.ts"],"sourcesContent":["/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport {\n  checkServerIdentity,\n  CipherNameAndProtocol,\n  ConnectionOptions,\n  PeerCertificate,\n  TLSSocket,\n} from 'tls';\nimport { StatusObject } from './call-interface';\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport {\n  ChannelzCallTracker,\n  registerChannelzSocket,\n  SocketInfo,\n  SocketRef,\n  TlsInfo,\n  unregisterChannelzRef,\n} from './channelz';\nimport { LogVerbosity } from './constants';\nimport { getProxiedConnection, ProxyConnectionResult } from './http_proxy';\nimport * as logging from './logging';\nimport { getDefaultAuthority } from './resolver';\nimport {\n  stringToSubchannelAddress,\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport * as net from 'net';\nimport {\n  Http2SubchannelCall,\n  SubchannelCall,\n  SubchannelCallInterceptingListener,\n} from './subchannel-call';\nimport { Metadata } from './metadata';\nimport { getNextCallNumber } from './call-number';\n\nconst TRACER_NAME = 'transport';\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\n\nconst clientVersion = require('../../package.json').version;\n\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT,\n} = http2.constants;\n\nconst KEEPALIVE_TIMEOUT_MS = 20000;\n\nexport interface CallEventTracker {\n  addMessageSent(): void;\n  addMessageReceived(): void;\n  onCallEnd(status: StatusObject): void;\n  onStreamEnd(success: boolean): void;\n}\n\nexport interface TransportDisconnectListener {\n  (tooManyPings: boolean): void;\n}\n\nexport interface Transport {\n  getChannelzRef(): SocketRef;\n  getPeerName(): string;\n  createCall(\n    metadata: Metadata,\n    host: string,\n    method: string,\n    listener: SubchannelCallInterceptingListener,\n    subchannelCallStatsTracker: Partial<CallEventTracker>\n  ): SubchannelCall;\n  addDisconnectListener(listener: TransportDisconnectListener): void;\n  shutdown(): void;\n}\n\nconst tooManyPingsData: Buffer = Buffer.from('too_many_pings', 'ascii');\n\nclass Http2Transport implements Transport {\n  /**\n   * The amount of time in between sending pings\n   */\n  private keepaliveTimeMs = -1;\n  /**\n   * The amount of time to wait for an acknowledgement after sending a ping\n   */\n  private keepaliveTimeoutMs: number = KEEPALIVE_TIMEOUT_MS;\n  /**\n   * Timer reference for timeout that indicates when to send the next ping\n   */\n  private keepaliveTimerId: NodeJS.Timer | null = null;\n  /**\n   * Indicates that the keepalive timer ran out while there were no active\n   * calls, and a ping should be sent the next time a call starts.\n   */\n  private pendingSendKeepalivePing = false;\n  /**\n   * Timer reference tracking when the most recent ping will be considered lost\n   */\n  private keepaliveTimeoutId: NodeJS.Timer | null = null;\n  /**\n   * Indicates whether keepalive pings should be sent without any active calls\n   */\n  private keepaliveWithoutCalls = false;\n\n  private userAgent: string;\n\n  private activeCalls: Set<Http2SubchannelCall> = new Set();\n\n  private subchannelAddressString: string;\n\n  private disconnectListeners: TransportDisconnectListener[] = [];\n\n  private disconnectHandled = false;\n\n  // Channelz info\n  private channelzRef: SocketRef;\n  private readonly channelzEnabled: boolean = true;\n  private streamTracker = new ChannelzCallTracker();\n  private keepalivesSent = 0;\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private lastMessageSentTimestamp: Date | null = null;\n  private lastMessageReceivedTimestamp: Date | null = null;\n\n  constructor(\n    private session: http2.ClientHttp2Session,\n    subchannelAddress: SubchannelAddress,\n    options: ChannelOptions,\n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n    private remoteName: string | null\n  ) {\n    /* Populate subchannelAddressString and channelzRef before doing anything\n     * else, because they are used in the trace methods. */\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzRef = registerChannelzSocket(\n      this.subchannelAddressString,\n      () => this.getChannelzInfo(),\n      this.channelzEnabled\n    );\n    // Build user-agent string.\n    this.userAgent = [\n      options['grpc.primary_user_agent'],\n      `grpc-node-js/${clientVersion}`,\n      options['grpc.secondary_user_agent'],\n    ]\n      .filter(e => e)\n      .join(' '); // remove falsey values first\n\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms']!;\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms']!;\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls =\n        options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n\n    session.once('close', () => {\n      this.trace('session closed');\n      this.stopKeepalivePings();\n      this.handleDisconnect();\n    });\n    session.once(\n      'goaway',\n      (errorCode: number, lastStreamID: number, opaqueData: Buffer) => {\n        let tooManyPings = false;\n        /* See the last paragraph of\n         * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n        if (\n          errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n          opaqueData.equals(tooManyPingsData)\n        ) {\n          tooManyPings = true;\n        }\n        this.trace('connection closed by GOAWAY with code ' + errorCode);\n        this.reportDisconnectToOwner(tooManyPings);\n      }\n    );\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace('connection closed with error ' + (error as Error).message);\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', (settings: http2.Settings) => {\n        this.trace(\n          'new settings received' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n      session.on('localSettings', (settings: http2.Settings) => {\n        this.trace(\n          'local settings acknowledged by remote' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n    }\n    /* Start the keepalive timer last, because this can trigger trace logs,\n     * which should only happen after everything else is set up. */\n    if (this.keepaliveWithoutCalls) {\n      this.maybeStartKeepalivePingTimer();\n    }\n  }\n\n  private getChannelzInfo(): SocketInfo {\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress\n      ? stringToSubchannelAddress(\n          sessionSocket.remoteAddress,\n          sessionSocket.remotePort\n        )\n      : null;\n    const localAddress = sessionSocket.localAddress\n      ? stringToSubchannelAddress(\n          sessionSocket.localAddress,\n          sessionSocket.localPort\n        )\n      : null;\n    let tlsInfo: TlsInfo | null;\n    if (this.session.encrypted) {\n      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n      const cipherInfo: CipherNameAndProtocol & { standardName?: string } =\n        tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: cipherInfo.standardName ?? null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate:\n          certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate:\n          peerCertificate && 'raw' in peerCertificate\n            ? peerCertificate.raw\n            : null,\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo: SocketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp:\n        this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: this.session.state.localWindowSize ?? null,\n      remoteFlowControlWindow: this.session.state.remoteWindowSize ?? null,\n    };\n    return socketInfo;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private keepaliveTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'keepalive',\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private flowControlTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      FLOW_CONTROL_TRACER_NAME,\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private internalsTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'transport_internals',\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  /**\n   * Indicate to the owner of this object that this transport should no longer\n   * be used. That happens if the connection drops, or if the server sends a\n   * GOAWAY.\n   * @param tooManyPings If true, this was triggered by a GOAWAY with data\n   * indicating that the session was closed becaues the client sent too many\n   * pings.\n   * @returns\n   */\n  private reportDisconnectToOwner(tooManyPings: boolean) {\n    if (this.disconnectHandled) {\n      return;\n    }\n    this.disconnectHandled = true;\n    this.disconnectListeners.forEach(listener => listener(tooManyPings));\n  }\n\n  /**\n   * Handle connection drops, but not GOAWAYs.\n   */\n  private handleDisconnect() {\n    this.reportDisconnectToOwner(false);\n    /* Give calls an event loop cycle to finish naturally before reporting the\n     * disconnnection to them. */\n    setImmediate(() => {\n      for (const call of this.activeCalls) {\n        call.onDisconnect();\n      }\n    });\n  }\n\n  addDisconnectListener(listener: TransportDisconnectListener): void {\n    this.disconnectListeners.push(listener);\n  }\n\n  private clearKeepaliveTimer() {\n    if (!this.keepaliveTimerId) {\n      return;\n    }\n    clearTimeout(this.keepaliveTimerId);\n    this.keepaliveTimerId = null;\n  }\n\n  private clearKeepaliveTimeout() {\n    if (!this.keepaliveTimeoutId) {\n      return;\n    }\n    clearTimeout(this.keepaliveTimeoutId);\n    this.keepaliveTimeoutId = null;\n  }\n\n  private canSendPing() {\n    return (\n      this.keepaliveTimeMs > 0 &&\n      (this.keepaliveWithoutCalls || this.activeCalls.size > 0)\n    );\n  }\n\n  private maybeSendPing() {\n    this.clearKeepaliveTimer();\n    if (!this.canSendPing()) {\n      this.pendingSendKeepalivePing = true;\n      return;\n    }\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace(\n      'Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms'\n    );\n    if (!this.keepaliveTimeoutId) {\n      this.keepaliveTimeoutId = setTimeout(() => {\n        this.keepaliveTrace('Ping timeout passed without response');\n        this.handleDisconnect();\n      }, this.keepaliveTimeoutMs);\n      this.keepaliveTimeoutId.unref?.();\n    }\n    try {\n      this.session!.ping(\n        (err: Error | null, duration: number, payload: Buffer) => {\n          this.keepaliveTrace('Received ping response');\n          this.clearKeepaliveTimeout();\n          this.maybeStartKeepalivePingTimer();\n        }\n      );\n    } catch (e) {\n      /* If we fail to send a ping, the connection is no longer functional, so\n       * we should discard it. */\n      this.handleDisconnect();\n    }\n  }\n\n  /**\n   * Starts the keepalive ping timer if appropriate. If the timer already ran\n   * out while there were no active requests, instead send a ping immediately.\n   * If the ping timer is already running or a ping is currently in flight,\n   * instead do nothing and wait for them to resolve.\n   */\n  private maybeStartKeepalivePingTimer() {\n    if (!this.canSendPing()) {\n      return;\n    }\n    if (this.pendingSendKeepalivePing) {\n      this.pendingSendKeepalivePing = false;\n      this.maybeSendPing();\n    } else if (!this.keepaliveTimerId && !this.keepaliveTimeoutId) {\n      this.keepaliveTrace(\n        'Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms'\n      );\n      this.keepaliveTimerId = setTimeout(() => {\n        this.maybeSendPing();\n      }, this.keepaliveTimeMs).unref?.();\n    }\n    /* Otherwise, there is already either a keepalive timer or a ping pending,\n     * wait for those to resolve. */\n  }\n\n  private stopKeepalivePings() {\n    if (this.keepaliveTimerId) {\n      clearTimeout(this.keepaliveTimerId);\n      this.keepaliveTimerId = null;\n    }\n    this.clearKeepaliveTimeout();\n  }\n\n  private removeActiveCall(call: Http2SubchannelCall) {\n    this.activeCalls.delete(call);\n    if (this.activeCalls.size === 0) {\n      this.session.unref();\n    }\n  }\n\n  private addActiveCall(call: Http2SubchannelCall) {\n    this.activeCalls.add(call);\n    if (this.activeCalls.size === 1) {\n      this.session.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.maybeStartKeepalivePingTimer();\n      }\n    }\n  }\n\n  createCall(\n    metadata: Metadata,\n    host: string,\n    method: string,\n    listener: SubchannelCallInterceptingListener,\n    subchannelCallStatsTracker: Partial<CallEventTracker>\n  ): Http2SubchannelCall {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = host;\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = method;\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream: http2.ClientHttp2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session!.request(headers);\n    } catch (e) {\n      this.handleDisconnect();\n      throw e;\n    }\n    this.flowControlTrace(\n      'local window size: ' +\n        this.session.state.localWindowSize +\n        ' remote window size: ' +\n        this.session.state.remoteWindowSize\n    );\n    this.internalsTrace(\n      'session.closed=' +\n        this.session.closed +\n        ' session.destroyed=' +\n        this.session.destroyed +\n        ' session.socket.destroyed=' +\n        this.session.socket.destroyed\n    );\n    let eventTracker: CallEventTracker;\n    // eslint-disable-next-line prefer-const\n    let call: Http2SubchannelCall;\n    if (this.channelzEnabled) {\n      this.streamTracker.addCallStarted();\n      eventTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n          subchannelCallStatsTracker.addMessageSent?.();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n          this.lastMessageReceivedTimestamp = new Date();\n          subchannelCallStatsTracker.addMessageReceived?.();\n        },\n        onCallEnd: status => {\n          subchannelCallStatsTracker.onCallEnd?.(status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n          subchannelCallStatsTracker.onStreamEnd?.(success);\n        },\n      };\n    } else {\n      eventTracker = {\n        addMessageSent: () => {\n          subchannelCallStatsTracker.addMessageSent?.();\n        },\n        addMessageReceived: () => {\n          subchannelCallStatsTracker.addMessageReceived?.();\n        },\n        onCallEnd: status => {\n          subchannelCallStatsTracker.onCallEnd?.(status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          subchannelCallStatsTracker.onStreamEnd?.(success);\n        },\n      };\n    }\n    call = new Http2SubchannelCall(\n      http2Stream,\n      eventTracker,\n      listener,\n      this,\n      getNextCallNumber()\n    );\n    this.addActiveCall(call);\n    return call;\n  }\n\n  getChannelzRef(): SocketRef {\n    return this.channelzRef;\n  }\n\n  getPeerName() {\n    return this.subchannelAddressString;\n  }\n\n  shutdown() {\n    this.session.close();\n    unregisterChannelzRef(this.channelzRef);\n  }\n}\n\nexport interface SubchannelConnector {\n  connect(\n    address: SubchannelAddress,\n    credentials: ChannelCredentials,\n    options: ChannelOptions\n  ): Promise<Transport>;\n  shutdown(): void;\n}\n\nexport class Http2SubchannelConnector implements SubchannelConnector {\n  private session: http2.ClientHttp2Session | null = null;\n  private isShutdown = false;\n  constructor(private channelTarget: GrpcUri) {}\n  private trace(text: string) {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      uriToString(this.channelTarget) + ' ' + text\n    );\n  }\n  private createSession(\n    address: SubchannelAddress,\n    credentials: ChannelCredentials,\n    options: ChannelOptions,\n    proxyConnectionResult: ProxyConnectionResult\n  ): Promise<Http2Transport> {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    return new Promise<Http2Transport>((resolve, reject) => {\n      let remoteName: string | null;\n      if (proxyConnectionResult.realTarget) {\n        remoteName = uriToString(proxyConnectionResult.realTarget);\n        this.trace(\n          'creating HTTP/2 session through proxy to ' +\n            uriToString(proxyConnectionResult.realTarget)\n        );\n      } else {\n        remoteName = null;\n        this.trace(\n          'creating HTTP/2 session to ' + subchannelAddressToString(address)\n        );\n      }\n      const targetAuthority = getDefaultAuthority(\n        proxyConnectionResult.realTarget ?? this.channelTarget\n      );\n      let connectionOptions: http2.SecureClientSessionOptions =\n        credentials._getConnectionOptions() || {};\n      connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n      if ('grpc-node.max_session_memory' in options) {\n        connectionOptions.maxSessionMemory =\n          options['grpc-node.max_session_memory'];\n      } else {\n        /* By default, set a very large max session memory limit, to effectively\n         * disable enforcement of the limit. Some testing indicates that Node's\n         * behavior degrades badly when this limit is reached, so we solve that\n         * by disabling the check entirely. */\n        connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n      }\n      let addressScheme = 'http://';\n      if ('secureContext' in connectionOptions) {\n        addressScheme = 'https://';\n        // If provided, the value of grpc.ssl_target_name_override should be used\n        // to override the target hostname when checking server identity.\n        // This option is used for testing only.\n        if (options['grpc.ssl_target_name_override']) {\n          const sslTargetNameOverride =\n            options['grpc.ssl_target_name_override']!;\n          connectionOptions.checkServerIdentity = (\n            host: string,\n            cert: PeerCertificate\n          ): Error | undefined => {\n            return checkServerIdentity(sslTargetNameOverride, cert);\n          };\n          connectionOptions.servername = sslTargetNameOverride;\n        } else {\n          const authorityHostname =\n            splitHostPort(targetAuthority)?.host ?? 'localhost';\n          // We want to always set servername to support SNI\n          connectionOptions.servername = authorityHostname;\n        }\n        if (proxyConnectionResult.socket) {\n          /* This is part of the workaround for\n           * https://github.com/nodejs/node/issues/32922. Without that bug,\n           * proxyConnectionResult.socket would always be a plaintext socket and\n           * this would say\n           * connectionOptions.socket = proxyConnectionResult.socket; */\n          connectionOptions.createConnection = (authority, option) => {\n            return proxyConnectionResult.socket!;\n          };\n        }\n      } else {\n        /* In all but the most recent versions of Node, http2.connect does not use\n         * the options when establishing plaintext connections, so we need to\n         * establish that connection explicitly. */\n        connectionOptions.createConnection = (authority, option) => {\n          if (proxyConnectionResult.socket) {\n            return proxyConnectionResult.socket;\n          } else {\n            /* net.NetConnectOpts is declared in a way that is more restrictive\n             * than what net.connect will actually accept, so we use the type\n             * assertion to work around that. */\n            return net.connect(address);\n          }\n        };\n      }\n\n      connectionOptions = {\n        ...connectionOptions,\n        ...address,\n        enableTrace: options['grpc-node.tls_enable_trace'] === 1,\n      };\n\n      /* http2.connect uses the options here:\n       * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n       * The spread operator overides earlier values with later ones, so any port\n       * or host values in the options will be used rather than any values extracted\n       * from the first argument. In addition, the path overrides the host and port,\n       * as documented for plaintext connections here:\n       * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n       * and for TLS connections here:\n       * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n       * earlier versions of Node, http2.connect passes these options to\n       * tls.connect but not net.connect, so in the insecure case we still need\n       * to set the createConnection option above to create the connection\n       * explicitly. We cannot do that in the TLS case because http2.connect\n       * passes necessary additional options to tls.connect.\n       * The first argument just needs to be parseable as a URL and the scheme\n       * determines whether the connection will be established over TLS or not.\n       */\n      const session = http2.connect(\n        addressScheme + targetAuthority,\n        connectionOptions\n      );\n      this.session = session;\n      session.unref();\n      session.once('connect', () => {\n        session.removeAllListeners();\n        resolve(new Http2Transport(session, address, options, remoteName));\n        this.session = null;\n      });\n      session.once('close', () => {\n        this.session = null;\n        reject();\n      });\n      session.once('error', error => {\n        this.trace('connection failed with error ' + (error as Error).message);\n      });\n    });\n  }\n  connect(\n    address: SubchannelAddress,\n    credentials: ChannelCredentials,\n    options: ChannelOptions\n  ): Promise<Http2Transport> {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions: ConnectionOptions =\n      credentials._getConnectionOptions() || {};\n\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = options['grpc.ssl_target_name_override']!;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = getDefaultAuthority(\n            parseUri(options['grpc.http_connect_target'] as string) ?? {\n              path: 'localhost',\n            }\n          );\n          const hostPort = splitHostPort(targetPath);\n          connectionOptions.servername = hostPort?.host ?? targetPath;\n        }\n      }\n      if (options['grpc-node.tls_enable_trace']) {\n        connectionOptions.enableTrace = true;\n      }\n    }\n\n    return getProxiedConnection(address, options, connectionOptions).then(\n      result => this.createSession(address, credentials, options, result)\n    );\n  }\n\n  shutdown(): void {\n    this.isShutdown = true;\n    this.session?.close();\n    this.session = null;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}