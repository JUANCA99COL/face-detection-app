{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.PickFirstLoadBalancer = exports.shuffled = exports.PickFirstLoadBalancingConfig = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst picker_1 = require(\"./picker\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst TRACER_NAME = 'pick_first';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n  constructor(shuffleAddressList) {\n    this.shuffleAddressList = shuffleAddressList;\n  }\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n  toJsonObject() {\n    return {\n      [TYPE_NAME]: {\n        shuffleAddressList: this.shuffleAddressList\n      }\n    };\n  }\n  getShuffleAddressList() {\n    return this.shuffleAddressList;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj) {\n    if ('shuffleAddressList' in obj && !(typeof obj.shuffleAddressList === 'boolean')) {\n      throw new Error('pick_first config field shuffleAddressList must be a boolean if provided');\n    }\n    return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\n  }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker {\n  constructor(subchannel) {\n    this.subchannel = subchannel;\n  }\n  pick(pickArgs) {\n    return {\n      pickResultType: picker_1.PickResultType.COMPLETE,\n      subchannel: this.subchannel,\n      status: null,\n      onCallStarted: null,\n      onCallEnded: null\n    };\n  }\n}\n/**\n * Return a new array with the elements of the input array in a random order\n * @param list The input array\n * @returns A shuffled array of the elements of list\n */\nfunction shuffled(list) {\n  const result = list.slice();\n  for (let i = result.length - 1; i > 1; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = result[i];\n    result[i] = result[j];\n    result[j] = temp;\n  }\n  return result;\n}\nexports.shuffled = shuffled;\nclass PickFirstLoadBalancer {\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  constructor(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n    /**\n     * The list of subchannels this load balancer is currently attempting to\n     * connect to.\n     */\n    this.children = [];\n    /**\n     * The current connectivity state of the load balancer.\n     */\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The index within the `subchannels` array of the subchannel with the most\n     * recently started connection attempt.\n     */\n    this.currentSubchannelIndex = 0;\n    /**\n     * The currently picked subchannel used for making calls. Populated if\n     * and only if the load balancer's current state is READY. In that case,\n     * the subchannel's current state is also READY.\n     */\n    this.currentPick = null;\n    /**\n     * Listener callback attached to each subchannel in the `subchannels` list\n     * while establishing a connection.\n     */\n    this.subchannelStateListener = (subchannel, previousState, newState) => {\n      this.onSubchannelStateUpdate(subchannel, previousState, newState);\n    };\n    this.triedAllSubchannels = false;\n    /**\n     * The LB policy enters sticky TRANSIENT_FAILURE mode when all\n     * subchannels have failed to connect at least once, and it stays in that\n     * mode until a connection attempt is successful. While in sticky TF mode,\n     * the LB policy continuously attempts to connect to all of its subchannels.\n     */\n    this.stickyTransientFailureMode = false;\n    this.connectionDelayTimeout = setTimeout(() => {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n  }\n  allChildrenHaveReportedTF() {\n    return this.children.every(child => child.hasReportedTransientFailure);\n  }\n  calculateAndReportNewState() {\n    if (this.currentPick) {\n      this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick));\n    } else if (this.children.length === 0) {\n      this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    } else {\n      if (this.stickyTransientFailureMode) {\n        this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n      } else {\n        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n      }\n    }\n  }\n  maybeEnterStickyTransientFailureMode() {\n    if (this.stickyTransientFailureMode) {\n      return;\n    }\n    if (!this.allChildrenHaveReportedTF()) {\n      return;\n    }\n    this.stickyTransientFailureMode = true;\n    this.channelControlHelper.requestReresolution();\n    for (const {\n      subchannel\n    } of this.children) {\n      subchannel.startConnecting();\n    }\n    this.calculateAndReportNewState();\n  }\n  removeCurrentPick() {\n    if (this.currentPick !== null) {\n      /* Unref can cause a state change, which can cause a change in the value\n       * of this.currentPick, so we hold a local reference to make sure that\n       * does not impact this function. */\n      const currentPick = this.currentPick;\n      this.currentPick = null;\n      currentPick.unref();\n      currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\n    }\n  }\n  onSubchannelStateUpdate(subchannel, previousState, newState) {\n    var _a;\n    if ((_a = this.currentPick) === null || _a === void 0 ? void 0 : _a.realSubchannelEquals(subchannel)) {\n      if (newState !== connectivity_state_1.ConnectivityState.READY) {\n        this.removeCurrentPick();\n        this.calculateAndReportNewState();\n        this.channelControlHelper.requestReresolution();\n      }\n      return;\n    }\n    for (const [index, child] of this.children.entries()) {\n      if (subchannel.realSubchannelEquals(child.subchannel)) {\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\n          this.pickSubchannel(child.subchannel);\n        }\n        if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n          child.hasReportedTransientFailure = true;\n          this.maybeEnterStickyTransientFailureMode();\n          if (index === this.currentSubchannelIndex) {\n            this.startNextSubchannelConnecting(index + 1);\n          }\n        }\n        child.subchannel.startConnecting();\n        return;\n      }\n    }\n  }\n  startNextSubchannelConnecting(startIndex) {\n    clearTimeout(this.connectionDelayTimeout);\n    if (this.triedAllSubchannels || this.stickyTransientFailureMode) {\n      return;\n    }\n    for (const [index, child] of this.children.entries()) {\n      if (index >= startIndex) {\n        const subchannelState = child.subchannel.getConnectivityState();\n        if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n          this.startConnecting(index);\n          return;\n        }\n      }\n    }\n    this.triedAllSubchannels = true;\n    this.maybeEnterStickyTransientFailureMode();\n  }\n  /**\n   * Have a single subchannel in the `subchannels` list start connecting.\n   * @param subchannelIndex The index into the `subchannels` list.\n   */\n  startConnecting(subchannelIndex) {\n    var _a, _b;\n    clearTimeout(this.connectionDelayTimeout);\n    this.currentSubchannelIndex = subchannelIndex;\n    if (this.children[subchannelIndex].subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n      trace('Start connecting to subchannel with address ' + this.children[subchannelIndex].subchannel.getAddress());\n      process.nextTick(() => {\n        this.children[subchannelIndex].subchannel.startConnecting();\n      });\n    }\n    this.connectionDelayTimeout = (_b = (_a = setTimeout(() => {\n      this.startNextSubchannelConnecting(subchannelIndex + 1);\n    }, CONNECTION_DELAY_INTERVAL_MS)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  pickSubchannel(subchannel) {\n    if (subchannel === this.currentPick) {\n      return;\n    }\n    trace('Pick subchannel with address ' + subchannel.getAddress());\n    this.stickyTransientFailureMode = false;\n    if (this.currentPick !== null) {\n      this.currentPick.unref();\n      this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());\n      this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n    }\n    this.currentPick = subchannel;\n    subchannel.ref();\n    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    this.resetSubchannelList();\n    clearTimeout(this.connectionDelayTimeout);\n    this.calculateAndReportNewState();\n  }\n  updateState(newState, picker) {\n    trace(connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n  resetSubchannelList() {\n    for (const child of this.children) {\n      if (child.subchannel !== this.currentPick) {\n        /* The connectivity state listener is the same whether the subchannel\n         * is in the list of children or it is the currentPick, so if it is in\n         * both, removing it here would cause problems. In particular, that\n         * always happens immediately after the subchannel is picked. */\n        child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      }\n      /* Refs are counted independently for the children list and the\n       * currentPick, so we call unref whether or not the child is the\n       * currentPick. Channelz child references are also refcounted, so\n       * removeChannelzChild can be handled the same way. */\n      child.subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());\n    }\n    this.currentSubchannelIndex = 0;\n    this.children = [];\n    this.triedAllSubchannels = false;\n  }\n  updateAddressList(addressList, lbConfig) {\n    if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\n      return;\n    }\n    /* Previously, an update would be discarded if it was identical to the\n     * previous update, to minimize churn. Now the DNS resolver is\n     * rate-limited, so that is less of a concern. */\n    if (lbConfig.getShuffleAddressList()) {\n      addressList = shuffled(addressList);\n    }\n    const newChildrenList = addressList.map(address => ({\n      subchannel: this.channelControlHelper.createSubchannel(address, {}),\n      hasReportedTransientFailure: false\n    }));\n    /* Ref each subchannel before resetting the list, to ensure that\n     * subchannels shared between the list don't drop to 0 refs during the\n     * transition. */\n    for (const {\n      subchannel\n    } of newChildrenList) {\n      subchannel.ref();\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    }\n    this.resetSubchannelList();\n    this.children = newChildrenList;\n    for (const {\n      subchannel\n    } of this.children) {\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        return;\n      }\n    }\n    for (const child of this.children) {\n      if (child.subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        child.hasReportedTransientFailure = true;\n      }\n    }\n    this.startNextSubchannelConnecting(0);\n    this.calculateAndReportNewState();\n  }\n  exitIdle() {\n    /* The pick_first LB policy is only in the IDLE state if it has no\n     * addresses to try to connect to and it has no picked subchannel.\n     * In that case, there is no meaningful action that can be taken here. */\n  }\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n  destroy() {\n    this.resetSubchannelList();\n    this.removeCurrentPick();\n  }\n  getTypeName() {\n    return TYPE_NAME;\n  }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nfunction setup() {\n  (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n  (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);\n}\nexports.setup = setup;","map":{"version":3,"names":["load_balancer_1","require","connectivity_state_1","picker_1","logging","constants_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","TYPE_NAME","CONNECTION_DELAY_INTERVAL_MS","PickFirstLoadBalancingConfig","constructor","shuffleAddressList","getLoadBalancerName","toJsonObject","getShuffleAddressList","createFromJson","obj","Error","exports","PickFirstPicker","subchannel","pick","pickArgs","pickResultType","PickResultType","COMPLETE","status","onCallStarted","onCallEnded","shuffled","list","result","slice","i","length","j","Math","floor","random","temp","PickFirstLoadBalancer","channelControlHelper","children","currentState","ConnectivityState","IDLE","currentSubchannelIndex","currentPick","subchannelStateListener","previousState","newState","onSubchannelStateUpdate","triedAllSubchannels","stickyTransientFailureMode","connectionDelayTimeout","setTimeout","clearTimeout","allChildrenHaveReportedTF","every","child","hasReportedTransientFailure","calculateAndReportNewState","updateState","READY","QueuePicker","TRANSIENT_FAILURE","UnavailablePicker","CONNECTING","maybeEnterStickyTransientFailureMode","requestReresolution","startConnecting","removeCurrentPick","unref","removeConnectivityStateListener","removeChannelzChild","getChannelzRef","_a","realSubchannelEquals","index","entries","pickSubchannel","startNextSubchannelConnecting","startIndex","subchannelState","getConnectivityState","subchannelIndex","getAddress","process","nextTick","_b","call","ref","addChannelzChild","resetSubchannelList","picker","updateAddressList","addressList","lbConfig","newChildrenList","map","address","createSubchannel","addConnectivityStateListener","exitIdle","resetBackoff","destroy","getTypeName","setup","registerLoadBalancerType","registerDefaultLoadBalancerType"],"sources":["/Users/juanrodriguez/Documents/projects/face-detection-app/node_modules/@grpc/grpc-js/src/load-balancer-pick-first.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  LoadBalancer,\n  ChannelControlHelper,\n  LoadBalancingConfig,\n  registerDefaultLoadBalancerType,\n  registerLoadBalancerType,\n} from './load-balancer';\nimport { ConnectivityState } from './connectivity-state';\nimport {\n  QueuePicker,\n  Picker,\n  PickArgs,\n  CompletePickResult,\n  PickResultType,\n  UnavailablePicker,\n} from './picker';\nimport { SubchannelAddress } from './subchannel-address';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport {\n  SubchannelInterface,\n  ConnectivityStateListener,\n} from './subchannel-interface';\n\nconst TRACER_NAME = 'pick_first';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'pick_first';\n\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\n\nexport class PickFirstLoadBalancingConfig implements LoadBalancingConfig {\n  constructor(private readonly shuffleAddressList: boolean) {}\n\n  getLoadBalancerName(): string {\n    return TYPE_NAME;\n  }\n\n  toJsonObject(): object {\n    return {\n      [TYPE_NAME]: {\n        shuffleAddressList: this.shuffleAddressList,\n      },\n    };\n  }\n\n  getShuffleAddressList() {\n    return this.shuffleAddressList;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj: any) {\n    if (\n      'shuffleAddressList' in obj &&\n      !(typeof obj.shuffleAddressList === 'boolean')\n    ) {\n      throw new Error(\n        'pick_first config field shuffleAddressList must be a boolean if provided'\n      );\n    }\n    return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\n  }\n}\n\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker implements Picker {\n  constructor(private subchannel: SubchannelInterface) {}\n\n  pick(pickArgs: PickArgs): CompletePickResult {\n    return {\n      pickResultType: PickResultType.COMPLETE,\n      subchannel: this.subchannel,\n      status: null,\n      onCallStarted: null,\n      onCallEnded: null,\n    };\n  }\n}\n\ninterface SubchannelChild {\n  subchannel: SubchannelInterface;\n  hasReportedTransientFailure: boolean;\n}\n\n/**\n * Return a new array with the elements of the input array in a random order\n * @param list The input array\n * @returns A shuffled array of the elements of list\n */\nexport function shuffled<T>(list: T[]): T[] {\n  const result = list.slice();\n  for (let i = result.length - 1; i > 1; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = result[i];\n    result[i] = result[j];\n    result[j] = temp;\n  }\n  return result;\n}\n\nexport class PickFirstLoadBalancer implements LoadBalancer {\n  /**\n   * The list of subchannels this load balancer is currently attempting to\n   * connect to.\n   */\n  private children: SubchannelChild[] = [];\n  /**\n   * The current connectivity state of the load balancer.\n   */\n  private currentState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The index within the `subchannels` array of the subchannel with the most\n   * recently started connection attempt.\n   */\n  private currentSubchannelIndex = 0;\n  /**\n   * The currently picked subchannel used for making calls. Populated if\n   * and only if the load balancer's current state is READY. In that case,\n   * the subchannel's current state is also READY.\n   */\n  private currentPick: SubchannelInterface | null = null;\n  /**\n   * Listener callback attached to each subchannel in the `subchannels` list\n   * while establishing a connection.\n   */\n  private subchannelStateListener: ConnectivityStateListener = (\n    subchannel,\n    previousState,\n    newState\n  ) => {\n    this.onSubchannelStateUpdate(subchannel, previousState, newState);\n  };\n  /**\n   * Timer reference for the timer tracking when to start\n   */\n  private connectionDelayTimeout: NodeJS.Timeout;\n\n  private triedAllSubchannels = false;\n\n  /**\n   * The LB policy enters sticky TRANSIENT_FAILURE mode when all\n   * subchannels have failed to connect at least once, and it stays in that\n   * mode until a connection attempt is successful. While in sticky TF mode,\n   * the LB policy continuously attempts to connect to all of its subchannels.\n   */\n  private stickyTransientFailureMode = false;\n\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  constructor(private readonly channelControlHelper: ChannelControlHelper) {\n    this.connectionDelayTimeout = setTimeout(() => {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n  }\n\n  private allChildrenHaveReportedTF(): boolean {\n    return this.children.every(child => child.hasReportedTransientFailure);\n  }\n\n  private calculateAndReportNewState() {\n    if (this.currentPick) {\n      this.updateState(\n        ConnectivityState.READY,\n        new PickFirstPicker(this.currentPick)\n      );\n    } else if (this.children.length === 0) {\n      this.updateState(ConnectivityState.IDLE, new QueuePicker(this));\n    } else {\n      if (this.stickyTransientFailureMode) {\n        this.updateState(\n          ConnectivityState.TRANSIENT_FAILURE,\n          new UnavailablePicker()\n        );\n      } else {\n        this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));\n      }\n    }\n  }\n\n  private maybeEnterStickyTransientFailureMode() {\n    if (this.stickyTransientFailureMode) {\n      return;\n    }\n    if (!this.allChildrenHaveReportedTF()) {\n      return;\n    }\n    this.stickyTransientFailureMode = true;\n    this.channelControlHelper.requestReresolution();\n    for (const { subchannel } of this.children) {\n      subchannel.startConnecting();\n    }\n    this.calculateAndReportNewState();\n  }\n\n  private removeCurrentPick() {\n    if (this.currentPick !== null) {\n      /* Unref can cause a state change, which can cause a change in the value\n       * of this.currentPick, so we hold a local reference to make sure that\n       * does not impact this function. */\n      const currentPick = this.currentPick;\n      this.currentPick = null;\n      currentPick.unref();\n      currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.removeChannelzChild(\n        currentPick.getChannelzRef()\n      );\n    }\n  }\n\n  private onSubchannelStateUpdate(\n    subchannel: SubchannelInterface,\n    previousState: ConnectivityState,\n    newState: ConnectivityState\n  ) {\n    if (this.currentPick?.realSubchannelEquals(subchannel)) {\n      if (newState !== ConnectivityState.READY) {\n        this.removeCurrentPick();\n        this.calculateAndReportNewState();\n        this.channelControlHelper.requestReresolution();\n      }\n      return;\n    }\n    for (const [index, child] of this.children.entries()) {\n      if (subchannel.realSubchannelEquals(child.subchannel)) {\n        if (newState === ConnectivityState.READY) {\n          this.pickSubchannel(child.subchannel);\n        }\n        if (newState === ConnectivityState.TRANSIENT_FAILURE) {\n          child.hasReportedTransientFailure = true;\n          this.maybeEnterStickyTransientFailureMode();\n          if (index === this.currentSubchannelIndex) {\n            this.startNextSubchannelConnecting(index + 1);\n          }\n        }\n        child.subchannel.startConnecting();\n        return;\n      }\n    }\n  }\n\n  private startNextSubchannelConnecting(startIndex: number) {\n    clearTimeout(this.connectionDelayTimeout);\n    if (this.triedAllSubchannels || this.stickyTransientFailureMode) {\n      return;\n    }\n    for (const [index, child] of this.children.entries()) {\n      if (index >= startIndex) {\n        const subchannelState = child.subchannel.getConnectivityState();\n        if (\n          subchannelState === ConnectivityState.IDLE ||\n          subchannelState === ConnectivityState.CONNECTING\n        ) {\n          this.startConnecting(index);\n          return;\n        }\n      }\n    }\n    this.triedAllSubchannels = true;\n    this.maybeEnterStickyTransientFailureMode();\n  }\n\n  /**\n   * Have a single subchannel in the `subchannels` list start connecting.\n   * @param subchannelIndex The index into the `subchannels` list.\n   */\n  private startConnecting(subchannelIndex: number) {\n    clearTimeout(this.connectionDelayTimeout);\n    this.currentSubchannelIndex = subchannelIndex;\n    if (\n      this.children[subchannelIndex].subchannel.getConnectivityState() ===\n      ConnectivityState.IDLE\n    ) {\n      trace(\n        'Start connecting to subchannel with address ' +\n          this.children[subchannelIndex].subchannel.getAddress()\n      );\n      process.nextTick(() => {\n        this.children[subchannelIndex].subchannel.startConnecting();\n      });\n    }\n    this.connectionDelayTimeout = setTimeout(() => {\n      this.startNextSubchannelConnecting(subchannelIndex + 1);\n    }, CONNECTION_DELAY_INTERVAL_MS).unref?.();\n  }\n\n  private pickSubchannel(subchannel: SubchannelInterface) {\n    if (subchannel === this.currentPick) {\n      return;\n    }\n    trace('Pick subchannel with address ' + subchannel.getAddress());\n    this.stickyTransientFailureMode = false;\n    if (this.currentPick !== null) {\n      this.currentPick.unref();\n      this.channelControlHelper.removeChannelzChild(\n        this.currentPick.getChannelzRef()\n      );\n      this.currentPick.removeConnectivityStateListener(\n        this.subchannelStateListener\n      );\n    }\n    this.currentPick = subchannel;\n    subchannel.ref();\n    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    this.resetSubchannelList();\n    clearTimeout(this.connectionDelayTimeout);\n    this.calculateAndReportNewState();\n  }\n\n  private updateState(newState: ConnectivityState, picker: Picker) {\n    trace(\n      ConnectivityState[this.currentState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n\n  private resetSubchannelList() {\n    for (const child of this.children) {\n      if (child.subchannel !== this.currentPick) {\n        /* The connectivity state listener is the same whether the subchannel\n         * is in the list of children or it is the currentPick, so if it is in\n         * both, removing it here would cause problems. In particular, that\n         * always happens immediately after the subchannel is picked. */\n        child.subchannel.removeConnectivityStateListener(\n          this.subchannelStateListener\n        );\n      }\n      /* Refs are counted independently for the children list and the\n       * currentPick, so we call unref whether or not the child is the\n       * currentPick. Channelz child references are also refcounted, so\n       * removeChannelzChild can be handled the same way. */\n      child.subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(\n        child.subchannel.getChannelzRef()\n      );\n    }\n    this.currentSubchannelIndex = 0;\n    this.children = [];\n    this.triedAllSubchannels = false;\n  }\n\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig\n  ): void {\n    if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\n      return;\n    }\n    /* Previously, an update would be discarded if it was identical to the\n     * previous update, to minimize churn. Now the DNS resolver is\n     * rate-limited, so that is less of a concern. */\n    if (lbConfig.getShuffleAddressList()) {\n      addressList = shuffled(addressList);\n    }\n    const newChildrenList = addressList.map(address => ({\n      subchannel: this.channelControlHelper.createSubchannel(address, {}),\n      hasReportedTransientFailure: false,\n    }));\n    /* Ref each subchannel before resetting the list, to ensure that\n     * subchannels shared between the list don't drop to 0 refs during the\n     * transition. */\n    for (const { subchannel } of newChildrenList) {\n      subchannel.ref();\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    }\n    this.resetSubchannelList();\n    this.children = newChildrenList;\n    for (const { subchannel } of this.children) {\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      if (subchannel.getConnectivityState() === ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        return;\n      }\n    }\n    for (const child of this.children) {\n      if (\n        child.subchannel.getConnectivityState() ===\n        ConnectivityState.TRANSIENT_FAILURE\n      ) {\n        child.hasReportedTransientFailure = true;\n      }\n    }\n    this.startNextSubchannelConnecting(0);\n    this.calculateAndReportNewState();\n  }\n\n  exitIdle() {\n    /* The pick_first LB policy is only in the IDLE state if it has no\n     * addresses to try to connect to and it has no picked subchannel.\n     * In that case, there is no meaningful action that can be taken here. */\n  }\n\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n\n  destroy() {\n    this.resetSubchannelList();\n    this.removeCurrentPick();\n  }\n\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n\nexport function setup(): void {\n  registerLoadBalancerType(\n    TYPE_NAME,\n    PickFirstLoadBalancer,\n    PickFirstLoadBalancingConfig\n  );\n  registerDefaultLoadBalancerType(TYPE_NAME);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}