{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subchannel = void 0;\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst channelz_1 = require(\"./channelz\");\nconst TRACER_NAME = 'subchannel';\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nclass Subchannel {\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(channelTarget, subchannelAddress, options, credentials, connector) {\n    var _a;\n    this.channelTarget = channelTarget;\n    this.subchannelAddress = subchannelAddress;\n    this.options = options;\n    this.credentials = credentials;\n    this.connector = connector;\n    /**\n     * The subchannel's current connectivity state. Invariant: `session` === `null`\n     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n     */\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The underlying http2 session used to make requests.\n     */\n    this.transport = null;\n    /**\n     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n     * CONNECTING instead of IDLE when the backoff timeout ends.\n     */\n    this.continueConnecting = false;\n    /**\n     * A list of listener functions that will be called whenever the connectivity\n     * state changes. Will be modified by `addConnectivityStateListener` and\n     * `removeConnectivityStateListener`\n     */\n    this.stateListeners = new Set();\n    /**\n     * Tracks channels and subchannel pools with references to this subchannel\n     */\n    this.refcount = 0;\n    // Channelz info\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n    // Channelz socket info\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    const backoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n    this.keepaliveTime = (_a = options['grpc.keepalive_time_ms']) !== null && _a !== void 0 ? _a : -1;\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n  getChannelzInfo() {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  refTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    } else {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n    }\n  }\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n  stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n  startConnectingInternal() {\n    let options = this.options;\n    if (options['grpc.keepalive_time_ms']) {\n      const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\n      options = Object.assign(Object.assign({}, options), {\n        'grpc.keepalive_time_ms': adjustedKeepaliveTime\n      });\n    }\n    this.connector.connect(this.subchannelAddress, this.credentials, options).then(transport => {\n      if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {\n        this.transport = transport;\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(transport.getChannelzRef());\n        }\n        transport.addDisconnectListener(tooManyPings => {\n          this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n          if (tooManyPings && this.keepaliveTime > 0) {\n            this.keepaliveTime *= 2;\n            logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);\n          }\n        });\n      }\n    }, error => {\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    });\n  }\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  transitionToState(oldStates, newState) {\n    var _a, _b;\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case connectivity_state_1.ConnectivityState.READY:\n        this.stopBackoff();\n        break;\n      case connectivity_state_1.ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();\n        this.transport = null;\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case connectivity_state_1.ConnectivityState.IDLE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();\n        this.transport = null;\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    for (const listener of this.stateListeners) {\n      listener(this, previousState, newState, this.keepaliveTime);\n    }\n    return true;\n  }\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    if (this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      if (this.channelzEnabled) {\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n      }\n      process.nextTick(() => {\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      });\n    }\n  }\n  unrefIfOneRef() {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n  createCall(metadata, host, method, listener) {\n    if (!this.transport) {\n      throw new Error('Cannot create call, subchannel not READY');\n    }\n    let statsTracker;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      this.streamTracker.addCallStarted();\n      statsTracker = {\n        onCallEnd: status => {\n          if (status.code === constants_1.Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        }\n      };\n    } else {\n      statsTracker = {};\n    }\n    return this.transport.createCall(metadata, host, method, listener, statsTracker);\n  }\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    process.nextTick(() => {\n      /* First, try to transition from IDLE to connecting. If that doesn't happen\n       * because the state is not currently IDLE, check if it is\n       * TRANSIENT_FAILURE, and if so indicate that it should go back to\n       * connecting after the backoff timer ends. Otherwise do nothing */\n      if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n          this.continueConnecting = true;\n        }\n      }\n    });\n  }\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener) {\n    this.stateListeners.add(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener) {\n    this.stateListeners.delete(listener);\n  }\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    process.nextTick(() => {\n      this.backoffTimeout.reset();\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    });\n  }\n  getAddress() {\n    return this.subchannelAddressString;\n  }\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  getRealSubchannel() {\n    return this;\n  }\n  realSubchannelEquals(other) {\n    return other.getRealSubchannel() === this;\n  }\n  throttleKeepalive(newKeepaliveTime) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n    }\n  }\n}\nexports.Subchannel = Subchannel;","map":{"version":3,"names":["connectivity_state_1","require","backoff_timeout_1","logging","constants_1","uri_parser_1","subchannel_address_1","channelz_1","TRACER_NAME","KEEPALIVE_MAX_TIME_MS","Subchannel","constructor","channelTarget","subchannelAddress","options","credentials","connector","connectivityState","ConnectivityState","IDLE","transport","continueConnecting","stateListeners","Set","refcount","channelzEnabled","callTracker","ChannelzCallTracker","childrenTracker","ChannelzChildrenTracker","streamTracker","backoffOptions","initialDelay","maxDelay","backoffTimeout","BackoffTimeout","handleBackoffTimer","subchannelAddressString","subchannelAddressToString","keepaliveTime","_a","channelzTrace","ChannelzTrace","channelzRef","registerChannelzSubchannel","getChannelzInfo","addTrace","trace","JSON","stringify","undefined","state","children","getChildLists","target","text","LogVerbosity","DEBUG","id","refTrace","transitionToState","TRANSIENT_FAILURE","CONNECTING","startBackoff","runOnce","stopBackoff","stop","reset","startConnectingInternal","adjustedKeepaliveTime","Math","min","Object","assign","connect","then","READY","refChild","getChannelzRef","addDisconnectListener","tooManyPings","log","ERROR","uriToString","error","oldStates","newState","indexOf","previousState","unrefChild","shutdown","isRunning","process","nextTick","_b","Error","listener","ref","unref","unregisterChannelzRef","unrefIfOneRef","createCall","metadata","host","method","statsTracker","addCallStarted","onCallEnd","status","code","Status","OK","addCallSucceeded","addCallFailed","startConnecting","getConnectivityState","addConnectivityStateListener","add","removeConnectivityStateListener","delete","resetBackoff","getAddress","getRealSubchannel","realSubchannelEquals","other","throttleKeepalive","newKeepaliveTime","exports"],"sources":["/Users/juanrodriguez/Documents/projects/face-detection-app/node_modules/@grpc/grpc-js/src/subchannel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelCredentials } from './channel-credentials';\nimport { Metadata } from './metadata';\nimport { ChannelOptions } from './channel-options';\nimport { ConnectivityState } from './connectivity-state';\nimport { BackoffTimeout, BackoffOptions } from './backoff-timeout';\nimport * as logging from './logging';\nimport { LogVerbosity, Status } from './constants';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport {\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport {\n  SubchannelRef,\n  ChannelzTrace,\n  ChannelzChildrenTracker,\n  SubchannelInfo,\n  registerChannelzSubchannel,\n  ChannelzCallTracker,\n  unregisterChannelzRef,\n} from './channelz';\nimport {\n  ConnectivityStateListener,\n  SubchannelInterface,\n} from './subchannel-interface';\nimport { SubchannelCallInterceptingListener } from './subchannel-call';\nimport { SubchannelCall } from './subchannel-call';\nimport { CallEventTracker, SubchannelConnector, Transport } from './transport';\n\nconst TRACER_NAME = 'subchannel';\n\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\n\nexport class Subchannel {\n  /**\n   * The subchannel's current connectivity state. Invariant: `session` === `null`\n   * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n   */\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The underlying http2 session used to make requests.\n   */\n  private transport: Transport | null = null;\n  /**\n   * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n   * CONNECTING instead of IDLE when the backoff timeout ends.\n   */\n  private continueConnecting = false;\n  /**\n   * A list of listener functions that will be called whenever the connectivity\n   * state changes. Will be modified by `addConnectivityStateListener` and\n   * `removeConnectivityStateListener`\n   */\n  private stateListeners: Set<ConnectivityStateListener> = new Set();\n\n  private backoffTimeout: BackoffTimeout;\n\n  private keepaliveTime: number;\n  /**\n   * Tracks channels and subchannel pools with references to this subchannel\n   */\n  private refcount = 0;\n\n  /**\n   * A string representation of the subchannel address, for logging/tracing\n   */\n  private subchannelAddressString: string;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: SubchannelRef;\n  private channelzTrace: ChannelzTrace;\n  private callTracker = new ChannelzCallTracker();\n  private childrenTracker = new ChannelzChildrenTracker();\n\n  // Channelz socket info\n  private streamTracker = new ChannelzCallTracker();\n\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(\n    private channelTarget: GrpcUri,\n    private subchannelAddress: SubchannelAddress,\n    private options: ChannelOptions,\n    private credentials: ChannelCredentials,\n    private connector: SubchannelConnector\n  ) {\n    const backoffOptions: BackoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms'],\n    };\n    this.backoffTimeout = new BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    this.keepaliveTime = options['grpc.keepalive_time_ms'] ?? -1;\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new ChannelzTrace();\n    this.channelzRef = registerChannelzSubchannel(\n      this.subchannelAddressString,\n      () => this.getChannelzInfo(),\n      this.channelzEnabled\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n    this.trace(\n      'Subchannel constructed with options ' +\n        JSON.stringify(options, undefined, 2)\n    );\n  }\n\n  private getChannelzInfo(): SubchannelInfo {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString,\n    };\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private refTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'subchannel_refcount',\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.CONNECTING\n      );\n    } else {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.IDLE\n      );\n    }\n  }\n\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  private startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n\n  private stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n\n  private startConnectingInternal() {\n    let options = this.options;\n    if (options['grpc.keepalive_time_ms']) {\n      const adjustedKeepaliveTime = Math.min(\n        this.keepaliveTime,\n        KEEPALIVE_MAX_TIME_MS\n      );\n      options = { ...options, 'grpc.keepalive_time_ms': adjustedKeepaliveTime };\n    }\n    this.connector\n      .connect(this.subchannelAddress, this.credentials, options)\n      .then(\n        transport => {\n          if (\n            this.transitionToState(\n              [ConnectivityState.CONNECTING],\n              ConnectivityState.READY\n            )\n          ) {\n            this.transport = transport;\n            if (this.channelzEnabled) {\n              this.childrenTracker.refChild(transport.getChannelzRef());\n            }\n            transport.addDisconnectListener(tooManyPings => {\n              this.transitionToState(\n                [ConnectivityState.READY],\n                ConnectivityState.IDLE\n              );\n              if (tooManyPings && this.keepaliveTime > 0) {\n                this.keepaliveTime *= 2;\n                logging.log(\n                  LogVerbosity.ERROR,\n                  `Connection to ${uriToString(this.channelTarget)} at ${\n                    this.subchannelAddressString\n                  } rejected by server because of excess pings. Increasing ping interval to ${\n                    this.keepaliveTime\n                  } ms`\n                );\n              }\n            });\n          }\n        },\n        error => {\n          this.transitionToState(\n            [ConnectivityState.CONNECTING],\n            ConnectivityState.TRANSIENT_FAILURE\n          );\n        }\n      );\n  }\n\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  private transitionToState(\n    oldStates: ConnectivityState[],\n    newState: ConnectivityState\n  ): boolean {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(\n      ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace(\n        'CT_INFO',\n        ConnectivityState[this.connectivityState] +\n          ' -> ' +\n          ConnectivityState[newState]\n      );\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case ConnectivityState.READY:\n        this.stopBackoff();\n        break;\n      case ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case ConnectivityState.TRANSIENT_FAILURE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        this.transport?.shutdown();\n        this.transport = null;\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case ConnectivityState.IDLE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        this.transport?.shutdown();\n        this.transport = null;\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    for (const listener of this.stateListeners) {\n      listener(this, previousState, newState, this.keepaliveTime);\n    }\n    return true;\n  }\n\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    if (this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      if (this.channelzEnabled) {\n        unregisterChannelzRef(this.channelzRef);\n      }\n      process.nextTick(() => {\n        this.transitionToState(\n          [ConnectivityState.CONNECTING, ConnectivityState.READY],\n          ConnectivityState.IDLE\n        );\n      });\n    }\n  }\n\n  unrefIfOneRef(): boolean {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n\n  createCall(\n    metadata: Metadata,\n    host: string,\n    method: string,\n    listener: SubchannelCallInterceptingListener\n  ): SubchannelCall {\n    if (!this.transport) {\n      throw new Error('Cannot create call, subchannel not READY');\n    }\n    let statsTracker: Partial<CallEventTracker>;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      this.streamTracker.addCallStarted();\n      statsTracker = {\n        onCallEnd: status => {\n          if (status.code === Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        },\n      };\n    } else {\n      statsTracker = {};\n    }\n    return this.transport.createCall(\n      metadata,\n      host,\n      method,\n      listener,\n      statsTracker\n    );\n  }\n\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    process.nextTick(() => {\n      /* First, try to transition from IDLE to connecting. If that doesn't happen\n       * because the state is not currently IDLE, check if it is\n       * TRANSIENT_FAILURE, and if so indicate that it should go back to\n       * connecting after the backoff timer ends. Otherwise do nothing */\n      if (\n        !this.transitionToState(\n          [ConnectivityState.IDLE],\n          ConnectivityState.CONNECTING\n        )\n      ) {\n        if (this.connectivityState === ConnectivityState.TRANSIENT_FAILURE) {\n          this.continueConnecting = true;\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.add(listener);\n  }\n\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.delete(listener);\n  }\n\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    process.nextTick(() => {\n      this.backoffTimeout.reset();\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.CONNECTING\n      );\n    });\n  }\n\n  getAddress(): string {\n    return this.subchannelAddressString;\n  }\n\n  getChannelzRef(): SubchannelRef {\n    return this.channelzRef;\n  }\n\n  getRealSubchannel(): this {\n    return this;\n  }\n\n  realSubchannelEquals(other: SubchannelInterface): boolean {\n    return other.getRealSubchannel() === this;\n  }\n\n  throttleKeepalive(newKeepaliveTime: number) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}